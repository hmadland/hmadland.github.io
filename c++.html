
<!DOCTYPE html>
<html lang="en">

<head style=background-color:#404040>

<meta charset="utf-8">
	<title>C++</title>
	<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

 <style >
  body{
  background-color: #404040;
  }
  
   /* Remove the navbar's default margin-bottom and rounded borders */ 
    .navbar {
      background-color: #90EE90;
      margin-bottom: 0;
      border-radius: 0;
    }
</style>
</head>


<body data-spy="scroll" data-target=".navbar" data-offset="50">
<!-- creating nav bar and the id's to drop to-->
<nav class="navbar navbar-inverse navbar-fixed-top">

  <ul class="nav navbar-nav">
    <li><a href="#section0">Top</a></li>
	<li><a href="#section1">Calculator & GUI</a></li>
	 <li><a href="#section2">Text Based Adventure Game</a></li>
	<li><a href="#section3">Binary Search Tree</a></li>
	<li><a href="../index.html">Home</a></li>
   </ul>
</nav>



<!-- TOP Info-->
<div id = "section0" style=color:#404040>
<div class="jumbotron jumbotron-fluid">
  <div class="container">
   <h1 class="display">C++ projects</h1>
  <p class="lead">Here are a few samples of my C++ projects.</p>
  <hr class="my">
   
</div>
</div>
</div>


<div id = "section1">

<div class="jumbotron jumbotron-fluid">
  <div class="container">
  <style>
  .body{
  background-color: #90EE90 !important;
  }
  
  </style>
  <div>
  <h1 class="display">Calculator & GUI</h1>
  <hr class="my">
   <h3>CalcGui.h</h3>
  <code>
	<xmp>
#ifndef GRIDLAYOUTDIALOG
#define GRIDLAYOUTDIALOG

#include <QDialog>
#include <QLineEdit>
#include "calculator.h"

class CalcGui : public QDialog
{
    Q_OBJECT

private:
    QLineEdit* lineEdit;
    Calculator calcEngine;

public:
    CalcGui(QWidget *parent = 0);
    ~CalcGui();

    QPushButton* btn0;
    QPushButton* btn1;
    QPushButton* btn2;
    QPushButton* btn3;
    QPushButton* btn4;
    QPushButton* btn5 ;
    QPushButton* btn6 ;
    QPushButton* btn7 ;
    QPushButton* btn8;
    QPushButton* btn9 ;

    QPushButton* btnDiv;
    QPushButton* btnMul;
    QPushButton* btnPlus ;
    QPushButton* btnSub;
    QPushButton* btnEqual ;
    QPushButton* btnPoint;
    QPushButton* btnRec;
    QPushButton* btnMod;
    QPushButton* btnSqrt;
    QPushButton* btnClear;

public slots:
    void buttonPressed();
};
#endif
</xmp>
  </code>
  
<h3>Calculator.h</h3>
<code>
<xmp>
#ifndef CALCULATOR_H
#define CALCULATOR_H

class Calculator {
public:
    friend class CalcGui;
    Calculator();

    enum opType
    {
        ADD ,
        SUBTRACT ,
        MULTIPLY ,
        DIVIDE,
        SQRT,
        NONE    //no stored operation
    };

    void store(double value);
    double handleOperation(Calculator::opType newOperation);
    double equalsPressed();
    void clear();

private:
    double num1;
    double num2;
    opType oper;
};
#endif // CALCULATOR_H
</xmp>
</code>

<h3>CalcGui.cpp</h3>
<code>
<xmp>
#include "CalcGui.h"
#include "Calculator.h"
#include <QPushButton>
#include <QLabel>
#include <QGridLayout>
#include <QSizePolicy>
#include <QLineEdit>
#include <QDialog>
#include <iostream>
#include <string>

using namespace std;

CalcGui::CalcGui(QWidget *parent) :
    QDialog(parent)
{
    //---------------NUMBER-BUTTONS------------------------
    btn0 = new QPushButton("0");
    btn1 = new QPushButton("1");
    btn2 = new QPushButton("2");
    btn3 = new QPushButton("3");
    btn4 = new QPushButton("4");
    btn5 = new QPushButton("5");
    btn6 = new QPushButton("6");
    btn7 = new QPushButton("7");
    btn8 = new QPushButton("8");
    btn9 = new QPushButton("9");

    //--------------OPERATOR-BUTTONS-----------------------
    btnDiv = new QPushButton("/");
    btnMul = new QPushButton("X");
    btnPlus = new QPushButton("+");
    btnSub = new QPushButton("-");
    btnEqual = new QPushButton("=");
    btnPoint = new QPushButton(".");
    btnRec = new QPushButton("1/x");
   /// btnMod = new QPushButton("%");
    btnSqrt = new QPushButton("√X");
    btnClear = new QPushButton("C");
    //-------------------------------------------------

    QHBoxLayout* bottomPane2 = new QHBoxLayout;
    bottomPane2->addWidget(btn0);
    bottomPane2->addWidget(btnPoint);
    bottomPane2->addWidget(btnPlus);
    bottomPane2->addWidget(btnEqual);
    bottomPane2->addStretch();

    QHBoxLayout* bottomPane = new QHBoxLayout;
    bottomPane->addWidget(btn1);
    bottomPane->addWidget(btn2);
    bottomPane->addWidget(btn3);
    bottomPane->addWidget(btnSub);
    bottomPane->addStretch();

    QHBoxLayout* midPane = new QHBoxLayout;
    midPane->addWidget(btn4);
    midPane->addWidget(btn5);
    midPane->addWidget(btn6);
    midPane->addWidget(btnMul);
    midPane->addWidget(btnRec);
    midPane->addStretch();

    QHBoxLayout* topPane = new QHBoxLayout;
    topPane->addWidget(btn7);
    topPane->addWidget(btn8);
    topPane->addWidget(btn9);
    topPane->addWidget(btnDiv);
    topPane->addWidget(btnMod);
    topPane->addStretch();

    QHBoxLayout* veryTopPane = new QHBoxLayout;
    veryTopPane->addWidget(btnSqrt);
    veryTopPane->addWidget(btnClear);
    veryTopPane->addStretch();

    QHBoxLayout* console = new QHBoxLayout;
    lineEdit = new QLineEdit("");
    console->addWidget(lineEdit);

    QVBoxLayout* mainLayout = new QVBoxLayout;
    mainLayout->addLayout(console);
    mainLayout->addLayout(veryTopPane);
    mainLayout->addLayout(topPane);
    mainLayout->addLayout(midPane);
    mainLayout->addLayout(bottomPane);
    mainLayout->addLayout(bottomPane2);

    setLayout(mainLayout);

    //------------Wire up events-----------------:
    connect(btn0, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn1, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn2, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn3, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn4, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn5, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn6, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn7, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn8, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btn9, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnDiv, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnMul, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnPlus, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnSub, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnEqual, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnPoint, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnRec, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnMod, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnSqrt, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
    connect(btnClear, SIGNAL(clicked()),
            this, SLOT(buttonPressed()));
}

//--------buttonPressed and prining to console----------------------
//---------------NUMBER-BUTTONS------------------------

void CalcGui::buttonPressed(){
    QObject* mySender = QObject::sender();

    if(mySender == btn0){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "0");
    }

    else if(mySender == btn1){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "1");
    }

    else if(mySender == btn2){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "2");
    }

    else if(mySender == btn3){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "3");
    }

    else if(mySender == btn4){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "4");
    }

    else if(mySender == btn5){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "5");
    }

    else if(mySender == btn6){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "6");
    }

    else if(mySender == btn7){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "7");
    }

    else if(mySender == btn8){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "8");
    }

    else if(mySender == btn9){
        QString text = lineEdit->text();
        if(text.contains("+") || text.contains("X")|| text.contains("/")
                || text.contains("-") || text.contains("%") || text.contains("√")){
            lineEdit->setText("");
        }
        lineEdit->setText(lineEdit->text()+ "9");
    }

    //--------------OPERATOR-BUTTONS----------------------------------------------------

    else if(mySender == btnPlus){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            lineEdit->setText("+");
            calcEngine.handleOperation(Calculator::ADD);

        }
    }

    else if(mySender == btnDiv){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            lineEdit->setText("/");
            calcEngine.handleOperation(Calculator::DIVIDE);
        }
    }

    else if(mySender == btnMul){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            lineEdit->setText("X");
            calcEngine.handleOperation(Calculator::MULTIPLY);
        }
    }

    else if(mySender == btnSub){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            lineEdit->setText("-");
            calcEngine.handleOperation(Calculator::SUBTRACT);
        }
    }

    else if(mySender == btnEqual){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            double x = calcEngine.equalsPressed();
            QString result = QString::number(x);
            lineEdit->setText(result);
        }
    }

    else if(mySender == btnSqrt){
        QString text = lineEdit->text();
        bool ok;
        double x = text.toDouble(&ok);
        if(ok) {
            calcEngine.store(x);
            lineEdit->setText("√");
            calcEngine.handleOperation(Calculator::SQRT);
        }
    }

    else if(mySender == btnPoint){
        QString text = lineEdit->text();
        string text2 = text.toStdString();
        if(text2.find(".") != true){
            lineEdit->setText(lineEdit->text()+ ".");
        }
    }

    else if(mySender == btnClear){
        lineEdit->setText("");
        calcEngine.clear();
    }
}

CalcGui::~CalcGui(){
}
</xmp>
</code>


<h3>Calculator.cpp</h3>
<code>
<xmp>
#include "Calculator.h"
#include <stdexcept>
#include <cmath>
using namespace std;

Calculator::Calculator() {
    num1 = 0;
    num2 = 0;
    oper = NONE;
}

void Calculator::store(double value){
    if(num2 == 0)
       num2 = value;
    else{
        num1 = value;
    }
}

double Calculator::handleOperation(Calculator::opType newOperation){
    if(oper == NONE){
        oper = newOperation;
        return num2;
    }
    else{
        if(oper == ADD){
            num1 = num2 + num1;
            num2 = 0;
        }
        //-----------subtraction not working with more than two variables-------
        else if(oper == SUBTRACT){
            num1 = num2;
            num2 = 0;
        }
        else if(oper == MULTIPLY){
            num1 = num2 * num1;
            num2 = 0;
        }

        //----------divide not working with more than two variables----------
        else if(oper == DIVIDE){
            num1 = num2 / num1;
            num2 = 0;
        }
        else if(oper == SQRT){
            num1 = sqrt(num2);
            num2 = 0;
        }
    }
    return 0;
}


double Calculator::equalsPressed() {
    double result;
    switch(oper){
    case NONE:
        result = num2;
        break;
    case ADD:
        result = num2 + num1;
        break;
        num2 = result;
    case SUBTRACT:
        result = num2 - num1;
        num2 = result;
        break;
    case MULTIPLY:
        result = num2 * num1;
        num2 = result;
        break;
    case DIVIDE:
        result = num2/num1;
        num2 = result;
        break;
    case SQRT:
        result = sqrt(num2);
        num2 = result;
        break;
    }
    return result;
}


void Calculator::clear() {
    num1 = 0;
    num2 = 0;
    oper = NONE;
}
</xmp>
</code>


<h3> main.cpp</h3>
<code>
<xmp>
#include <iostream>
#include <QApplication>
#include "CalcGui.h"
#include "Calculator.h"

using namespace std;

int main(int argc, char* argv[])
{
    QApplication app(argc, argv);

    CalcGui demo;
    demo.show();

    return app.exec();
}
</xmp>
</code>

  </div> 
</div>
</div>
</div>

<div id = "section2">

<div class="jumbotron jumbotron-fluid">
  <div class="container">
  <style>
  .body{
  background-color: #90EE90 !important;
  }
  
  </style>
  <div>
  <h1 class="display">Text Based Adventure Game </h1>
  <hr class="my">
   <h3>Location.h</h3>
  <code>
	<xmp>
#include <iostream>
#include <string>
using namespace std;

#ifndef LOCATION_H
#define LOCATION_H
#include <string>

using namespace std;

enum Direction{
    NORTH = 0,
    EAST = 1 ,
    WEST = 2,
    SOUTH = 3
};

class Location{
public:
    /**
     * @brief Location sets the name to "?" all neighbors to null and everything
     * else to false.
     */
    Location();

    /**
     * @brief Location sets name, exit, and sets the rest to null or false as appropriate.
     * @param locName name of location
     * @param isTheExit true or false statement
     */
    Location(string locName, bool isTheExit);

    /**
     * @brief getDescription returns a string containing the name of the location, a list of the directions
       possible to leave in, and if it has been visited before and marks visited if not.
     * @return a description of location
     */
    string getDescription();

    /**
     * @brief hasNeighbor returns true if there is another location in the specified direction, false if there is
       not (nullptr)
     * @param dir direction of neighbor
     * @return true or false
     */
    bool hasNeighbor(Direction dir);

    /**
     * @brief getNeighbor returns a pointer to the neighbor in the indicated direction or nullptr if there is not
       a neighbor
     * @param dir direction of location
     * @return pointer to neighbor indicated by direction given
     */
    Location* getNeighbor(Direction dir);

    /**
     * @brief setNeighbor stores the indicated Location pointer as the designated neighbor
     * @param dir direction of designated neighbor
     * @param neighborLoc location of neighbor
     */
    void setNeighbor(Direction dir, Location* neighborLoc);

    /**
     * @brief isExit returns true if the Location is an exit
     * @return true or false
     */
    bool isExit();

    /**
     * @brief visit marks a room as having been visited.
     */
    void visit();


private:
    string name;
    bool visited;
    bool exit;
    Location* neighbors[4];

};

#endif // LOCATION_H


</xmp>
  </code>
  
<h3>Location.cpp </h3>
<code>
<xmp>

#include "Location.h"
#include <iostream>
#include <string>
using namespace std;

Location::Location(){
    name = "?";
    visited = false;
    exit = false;
    neighbors[0] = {nullptr};
    neighbors[1] = {nullptr};
    neighbors[2] = {nullptr};
    neighbors[3] = {nullptr};
}

Location::Location(string locName, bool isTheExit){
    name = locName;
    visited = false;
    exit = isTheExit;
    neighbors[0] = {nullptr};
    neighbors[1] = {nullptr};
    neighbors[2] = {nullptr};
    neighbors[3] = {nullptr};
}

string Location::getDescription(){
    if(name == "a deep, dark cave"){
        if(visited == true){
            return"You are in a deep, dark cave. You have already been here. \n"
                  "Possible exits are North, South, and East. \n" ;
        }

        else{
            visited = true;
            return "You are now in a deep, dark cave. \n"
                   "Possible exits are North, South and East. \n" ;
        }
    }

    else if(name == "a collapsed cavern"){
        if(visited == true){
            return "You are now in a collapsed cavern. You have already been here.\n"
                   "The only possible exit is North. \n";
        }

        else{
            visited = true;
            return "You are now in a collapsed cavern. \n"
                   "The only possible exit is North. \n";
        }
    }

    else if(name == "a musty passage"){
        if(visited == true){
            return "You are now in a musty passage. You have already been here. \n"
                   "Possible exits are East and South. \n" ;
        }

        else{
            visited = true;
            return "You are now in a musty passage \n"
                   "Possible exits are East and South. \n"  ;
        }
    }

    else if(name == "the shores of an underground lake"){
        if(visited == true){
            return "You are now on the shores of an underground lake. You have already been here. \n"
                   "Possible exits are North, and West. \n" ;
        }

        else{
            visited = true;
            return "You are now on the shores of an underground lake \n"
                   "Possible exits are North, and West. \n" ;
        }
    }

    else if(name == "a twisting shaft"){
        if(visited == true){
            return "You are now in a twisting shaft. You have already been here. \n"
                   "Possible exits are East and South. \n" ;
        }
        else{
            visited = true;
            return "You are now in a twisting shaft \n"
                   "Possible exits are East and South. \n" ;

        }
    }

    else if (name == "a dusty alcove"){
        if(visited == true){
            return "You are now in a dusty alcove. You have already been here. \n"
                   "The only exit is South. \n";

        }

        else{
            visited = true;
            return "You are now in a dusty alcove \n"
                   "The only exit is South. \n" ;
        }
    }

    else if(name == "a passage to the surface"){
        if(visited == true){
            return "You are now in a passage to the surface. You have already been here. \n"
                   "Possible exits are West and North. \n" ;

        }

        else{
            visited = true;
            return "You are now in a passage to the surface \n"
                   "Possible exits are West and North. \n" ;
        }
    }

    else if(name == "the surface"){
        return "You made it to the surface. \n"
               "Congratulations! \n" ;
    }
}


bool Location:: hasNeighbor(Direction dir){
    if(neighbors[dir] == nullptr){
        return false;
    }
    else{
        return true;
    }
}

Location* Location::getNeighbor(Direction dir){
    return neighbors[dir];
}


void Location::setNeighbor(Direction dir, Location* neighborLoc){
    neighbors[dir] = neighborLoc;
}

bool Location::isExit(){
    if(name == "the surface"){
        return true;
    }
    else {
        return false;
    }
}

void Location::visit(){

    if(name == "a deep, dark cave"){
        visited = true;
    }

    else if(name == "a collapsed cavern"){
        visited = true;
    }

    else if(name == "a musty passage"){
        visited = true;
    }

    else if(name == "the shores of an underground lake"){
        visited = true;
    }

    else if(name == "a twisting shaft"){
        visited = true;
    }

    else if (name == "a dusty alcove"){
        visited = true;
    }

    else if(name == "a passage to the surface"){

        visited = true;

    }

    else if(name == "the surface"){
        visited = true;
    }
}

</xmp>
</code>

<h3>main.cpp</h3>
<code>
<xmp>

#include <iostream>
#include "Location.h"
using namespace std;

const int NUM_LOCATIONS = 8;

void buildMap(Location allLocations[]){
    allLocations[0] = Location("a deep, dark cave", false);
    allLocations[1] = Location("a collapsed cavern", false);
    allLocations[2] = Location("a musty passage", false);
    allLocations[3] = Location("the shores of an underground lake", false);
    allLocations[4] = Location("a twisting shaft", false);
    allLocations[5] = Location("a dusty alcove", false);
    allLocations[6] = Location("a passage to the surface", false);
    allLocations[7] = Location("the surface", true);


    allLocations[0].setNeighbor(SOUTH,&allLocations[1]);
    allLocations[0].setNeighbor(NORTH,&allLocations[2]);
    allLocations[0].setNeighbor(EAST,&allLocations[3]);

    allLocations[1].setNeighbor(NORTH,&allLocations[0]);

    allLocations[2].setNeighbor(EAST,&allLocations[4]);
    allLocations[2].setNeighbor(SOUTH,&allLocations[0]);

    allLocations[3].setNeighbor(NORTH,&allLocations[4]);
    allLocations[3].setNeighbor(WEST,&allLocations[0]);

    allLocations[4].setNeighbor(EAST, &allLocations[5]);
    allLocations[4].setNeighbor(SOUTH, &allLocations[3]);

    allLocations[5].setNeighbor(SOUTH,&allLocations[6]);

    allLocations[6].setNeighbor(WEST,&allLocations[7]);
    allLocations[6].setNeighbor(NORTH, &allLocations[5]);

    //allLocations[7].setNeighbor(,&allLocations[7]);
}

int main()
{
    Location allLocations[NUM_LOCATIONS];

    buildMap(allLocations);

    Location* currentLocation = &allLocations[0];

    cout << "To pick a direction type N, S, E, or W \n";

    while(currentLocation->isExit() == false){

        cout << currentLocation->getDescription();

        cout << "Pick a direction" << endl;
        char direction;
        cin >> direction;
        Direction dir;

        if (direction == 'N' ){
            dir = NORTH;
        }
        else if (direction == 'S' ){
            dir = SOUTH;
        }

        else if ( direction == 'E' ){
            dir = EAST;

        }
        else if ( direction == 'W'){
            dir = WEST;

        }
        else if (direction != 'N' || direction != 'S' || direction != 'E' || direction != 'W'){
            cout << "That's not a valid direction!" << endl;
        }

        if(currentLocation->hasNeighbor(dir) == true){
            currentLocation = currentLocation->getNeighbor(dir);

        }
    }

    cout << "You emerge safely from the maze!" << endl;
}
</xmp>
</code>
</div> 
</div>
</div>
</div>


<div id = "section3">

<div class="jumbotron jumbotron-fluid">
  <div class="container">
  <style>
  .body{
  background-color: #90EE90 !important;
  }
  
  </style>
  <div>
  <h1 class="display">Binary Search Tree </h1>
  <hr class="my">
   <h3>Myset.he</h3>
  <code>
	<xmp>
#ifndef MYSET
#define MYSET
#include "MySetNode.h"
#include <vector>

using namespace std;


template <class T>
class MySet {
public:  ///Public to allow testing of helper functions outside the class
    MySetNode<T>* root;
    ///Constructors/assignment op
    MySet();
    MySet(const MySet& other);

    MySet& operator=(const MySet& other);
    ///Destructor - deletes any child nodes
    ~MySet();
    void copy(MySetNode<T>* root);
    void duplicateSubTree(MySetNode<T>* startNode);
    bool contains(T item);
    MySet<T> unionWith(const MySet& other);
    void deleteSubTree(MySetNode<T>* startNode);
    T findLargest() const;
    bool addWords(T value);
    bool add(T value);
    int size();
    int depth();
    bool remove(T item);
    T extractLargest();

};

///if looked at in debugger it adds everthing but makes a linked list.
template<class T>
MySet<T> MySet<T>::unionWith(const MySet& other) {

    vector<T> v_one;
    MySet<T> otherCopy;

    otherCopy.copy(other.root);
    int y = root->nodeCount;
    for(int i = 0; i < y/2; i++){
        v_one.push_back(otherCopy.extractLargest());
    }

    for(int i = 0; i < v_one.size(); i++){
        T num = v_one.at(i);
        this->add(num);
    }
}


template<class T>
bool MySet<T>::add(T item){

    MySetNode<T>* parent;
    MySetNode<T>* current;
    if (root == nullptr)
        root = new MySetNode<T>(item);
    else
    {
        // Locate the parent node
        current = root;
        while (current != nullptr)
            if (item < current->item)
            {
                parent = current;
                current = current->left;
            }
            else if (item > current->item)
            {
                parent = current;
                current = current->right;
            }
            else
                return false; // Duplicate node not inserted
        // Create the new node and attach it to the parent node
        if (item < parent->item)
            parent->left = new MySetNode<T>(item);
        else
            parent->right = new MySetNode<T>(item);
        return true; // item inserted
    }
}



template<class T>
int MySet<T>::depth(){

    T max = 1;
    T max2 = 1;
    MySetNode<T>* current;
    MySetNode<T>* parent;

    current = this->root;
    if(this->root == nullptr){
        current = root;
        return max;
    }
    else{
        while(current!= nullptr){\
            parent = current;
            parent->item = current->item;
            current = current->right;
            max = max + 1;
        }
        while(current!= nullptr){
            parent = current;
            parent->item = current->item;
            current = current->left;
            max2 = max2 + 1;
        }
        if(max > max2){
            return max;
        }
        else{
            return max2;
        }
    }
}




template<class T>
bool MySet<T>::addWords(T item){

    MySetNode<T>* parent;
    MySetNode<T>* current;
    if (root == nullptr)
        root = new MySetNode<T>(item);
    else
    {
        // Locate the parent node
        current = root;
        while (current != nullptr)
            if (item < current->item)
            {
                parent = current;
                current = current->left;
            }
            else if (item > current->item)
            {
                parent = current;
                current = current->right;
            }
            else
                return false; // Duplicate node not inserted
        // Create the new node and attach it to the parent node
        if (parent->left == nullptr)
            parent->left = new MySetNode<T>(item);
        else
            parent->right = new MySetNode<T>(item);
        return true; // item inserted
    }
}


template<class T>
T MySet<T>::findLargest() const{
    T max;
    MySetNode<T>* current;
    MySetNode<T>* parent;
    current = this->root;
    if(this->root == nullptr){
        current = root;
        return 0;
    }
    else{
        while(current!= nullptr){\
            parent = current;
            parent->item = current->item;
            current = current->right;
            max = parent->item;
        }
        return max /*current->item*/;
    }
}

template<class T>
T MySet<T>::extractLargest(){
    T max = findLargest();
    remove(max);
    return max;
}


template <class T>
bool MySet<T>::remove(T item) {
    // Locate the node to be deleted and also locate its parent node
    MySetNode<T>* parent = nullptr;
    MySetNode<T>* current = root;
    while (current != nullptr)
    {
        if (item < current->item){
            parent = current;
            current = current->left;
        }
        else if (item > current->item){
            parent = current;
            current = current->right;
        }
        else
            break; // item is in the tree pointed by current
    }
    if (current == nullptr)
        return false;
    // item is not in the tree
    // Case 1: current has no left children
    if (current->left == nullptr){
        if (parent == nullptr){
            root = current->right;
        }
        else
        {
            if (item < parent->item)
                parent->left = current->right;
            else
                parent->right = current->right;
        }
        delete current; // Delete current
    } else{
        // the current node and also its parent
        MySetNode<T>* parentOfRightMost = current;
        MySetNode<T>* rightMost = current->left;
        while (rightMost->right != nullptr){
            parentOfRightMost = rightMost;
            rightMost = rightMost->right; // Keep going to the right
        }
        // Replace the item in current by the item in rightMost
        current->item = rightMost->item;
        // Eliminate rightmost node
        if (parentOfRightMost->right == rightMost)
            parentOfRightMost->right = rightMost->left;
        else
            // Special case: parentOfRightMost->right == current
            parentOfRightMost->left = rightMost->left;
        delete rightMost; // Delete rightMost
    }
    return true; // item inserted
}

template <class T>
bool MySet<T>::contains(T item){
    if(searchHelp(root, item) == nullptr){
        return false;
    }
    else{
        return true;
    }
}

template <class T>
void MySet<T>::deleteSubTree(MySetNode <T>* startNode) {
    if(startNode == nullptr){
        return;
    }
    deleteSubTree(startNode->left);
    deleteSubTree(startNode->right);
    delete startNode;
}

template <class T>
MySetNode<T>* duplicateSubTree(MySetNode<T>* startNode) {
    if(startNode == nullptr)
        return nullptr;
    MySetNode<T>* newNode = new MySetNode<T>(startNode->item);
    newNode->left = duplicateSubTree(startNode->left);
    newNode->right = duplicateSubTree(startNode->right);
    return newNode;
}


template <typename T>
void MySet<T>::copy(MySetNode<T>* root)
{
    if (root != NULL)
    {
        add(root->item);
        copy(root->left);
        copy(root->right);
    }
}

template <class T>
MySet<T>::MySet(const MySet& other) {
    root = duplicateSubTree(other.root);
}

template <class T>
MySet<T>::MySet(){
    root = nullptr;
}

template <class T>
MySet<T>::~MySet() {
    deleteSubTree(root);
}

template <class T>
MySet<T>& MySet<T>::operator=(const MySet& other){
    if(this != &other){
        deleteSubTree(root);
        root =duplicateSubTree(other.root);
    }
    return *this;
}

template <class T>
int MySet<T>::size(){
    return this->root->nodeCount;
}


#endif // MYSET


</xmp>
  </code>
  
<h3>MySetNode.h </h3>
<code>
<xmp>
#ifndef MYSETNODE
#define MYSETNODE
#include "MySet.h"
#include "MySetNode.h"

template <class T>
class MySetNode {
public:
    ///Store a value and two child pointers
    T item;
    MySetNode<T>* left;
    MySetNode<T>* right;
    ///Constructor - left/right set to null
    MySetNode(T val);
    ///Destructor - decrement counter
    ~MySetNode();
    ///Debugging purposes only - Not a normal feature
    ///  Used for tracking memory allocation, updated in constructor/destructor
    static int nodeCount;

    T searchHelp(MySetNode root, T item);

    void deleteSubTree(MySetNode <T>* startNode);

};

template <class T>
void MySetNode<T>::deleteSubTree(MySetNode <T>* startNode) {
    if(startNode == nullptr){
        return;
    }
    deleteSubTree(startNode->left);
    deleteSubTree(startNode->right);
    delete startNode;
}



template <class T>
T MySetNode<T>::searchHelp(MySetNode node, T item){
    if( node == nullptr){
        return false;
    }
    if(node == item){
        return true;
    }
    if(item < node){
        return searchhelp(node.left, item);
    }
    else{
        return searchHelp(node.right, item);
    }
}

template <class T>
int MySetNode<T>::nodeCount = 0;
template <class T>
MySetNode<T>::MySetNode(T val) {
    item = val;
    left = nullptr;
    right = nullptr;
    nodeCount++;
}

template <class T>
MySetNode<T>::~MySetNode() {
    nodeCount--;
}

#endif // MYSETNODE

</xmp>
</code>

<h3>title p</h3>
<code>
<xmp>
code goes here 
</xmp>
</code>


<h3> title </h3>
<code>
<xmp>
code goes here 
</xmp>
</code>


<h3> main.cpp </h3>
<code>
<xmp>

#include <iostream>
#include <ctime>
#include <vector>
#include "MySet.h"

using namespace std;

int main(){
    MySet <int> test;
    clock_t adding = clock();


    for(int i = 0; i < 5; i++){

        int r1 = (rand() % 100);         // v1 in the range 0-99
        int r2 = rand() % 1000;      // v2 in the range 0-999

        r1 = r1 * 1000;
        int random = r1 + r2;
        test.add(random);
    }

    clock_t count = clock() - adding;
    double sec = (1.0 * count / CLOCKS_PER_SEC);

    cout<< "adding took "<< sec << " seconds " << endl;
    cout << "The number of items in the set are: " << test.size() << endl;
    cout << "The depth of the set is: " << test.depth() << endl;


    cout << "The largest in the set is: " << test.extractLargest() << endl;
    for (int i = 0; i < 4; i++){
        cout << "The largest in the set now is: " << test.extractLargest() << endl;

    }
	}

</xmp>
</code>

  </div> 
</div>
</div>
</div>


</body>

